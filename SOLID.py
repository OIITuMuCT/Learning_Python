# Принципы SOLID 
# https://habr.com/ru/companies/productivity_inside/articles/505430/

# TODO S - Single Reponsobility(Принцип единственной ответственности)
"""Принцип служит для разделения типов поведения, благодаря которому ошибки,
вызванные модификациями в одном поведении, не распространялись на прочие, 
не связанные с ним типы."""
    # ? Каждый класс должен отвечать только за одну операцию.
    # * Я - Повар, Я Садовник Я - Маляр, Я - Водитель
    # ! А не Я - Повар, Садовник, Маляр и Водитель.
    # Назначение


# TODO O - Open-Closed(Принцип открытости-закрытости)
"""
Принцип служит для того, чтобы делать поведение класса более разнообразным, не
вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы
избегаете ошибок в тех фрагментах кода, где задействован этот класс.
"""
    # ? Классы должны быть открыты для расширения, но закрыты для модификации.
    # * Я умею резать - ведутся работы - Я умею резать и красить.
    # ! Я умею резать - ведутся работы - А теперь я умею красить.
    # Назначение


# TODO L - Liskov Substitution(Принцип подстановки Барбары Лисков)
"""
Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок
могут использовать одинаковым образом без нарушения работы программы
"""

    # ? Если П является подтипом Т, то любые объекты типа Т, присутствующие в
    # ? программе, могут заменяться объектами типа П без негативных последствий
    # ? для функциональности программы.
    # * Привет, я Сэм, готовлю кофе, Привет а, я Иден, сын Сэма.
    # * Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится
    # * родителем, а новый - его потомком. Класс-потомок дложен производить такие же операции, как 
    # * и класс-родитель. Это называется наследственностью.
    # * Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и 
    # * выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же
    # * типу. Класс-родитель продает кофе(в любых видах), значит, для класса-потомка приемлемо продавать
    # * капучино(разновидность кофе), но не приемлемо продавать воду.
    # ! Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от 
    # ! родителя и нарушает принцип.
    
    # Назначение

    
# TODO I - Interface Segregation(Принцип разделения интерфейсов)
"""
Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше - 
таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.
"""
    # ? Не следует ставить клиент в зависимость от методов, которые он не использует.
    # * Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается
    # * в пустую трату ресурса, а в случае, если класс выполняет эти действия не способен, ведет к 
    # * возникновению багов.
    # * Класс должен производить только те операции, которые необходимы для осуществления его функций. 
    # * Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они
    # * понадобятся другому классу в будущем.
    # Назначение


# TODO D - Dependency Inversion(Принцип инверсии зависимостей)
    # ? Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны 
    # ? зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от 
    # ? абстракций.
    # * Я режу пиццу любым доступным инструментом.
    # * Модули(или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
    # * Модули(или классы) нижнего уровня = инструменты, которые нужны для выполнения операций.
    # * Абстракции - представляют интерфейс, соединяющий два класса
    # * Детали = специфические характеристики работы инструмента
    # *     Согласно данному принципу, класс не должен соединяться с инструментом, который 
    # *     применяет для выполнения операции. Вместо этого он должен быть соединен с интерфейсом, 
    # *     который поможет установить связь между инструментом и классом.

    # *     Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику 
    # *     работы инструмента.Напротив, это инструмент должен подходить под требования интерфейса.
    # Назначение
    """
    Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов 
    нижнего уровня за счет введения интерфейсов.
    """

