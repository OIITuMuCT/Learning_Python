# Использование оператора nonlocal для изменений
def tester(start):
    state = start
    def nested(label):      # Каждый вызов получает собственное значение state
        nonlocal state      # Запоминает из объемлющей области видимости
        print(label, state)
        state += 1          # Нелокальную переменную разрешено изменять

    return nested

F = tester(0)               # При каждом вызове state инкрементируется
F('spam')
F('ham')
F('eggs')

G = tester(42)  # Создание нового объекта функции tester,который начинает с 42
G('spam')
G("eggs")       # Информация о состоянии обновилась на 43
F('bacon')  # Но функция F осталась там, где и была: 3
# Каждый вызов имеет разную информацию о состоянии
