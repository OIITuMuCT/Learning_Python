    1. Что такое абстрактный суперкласс? 
    
    Ответ:
            Абстрактный класс - это класс, который вызывает метод, но не наследует и не определяет его; он ожидает
        заполнение метода подклассом. Абстрактные суперклассы часто используют в качестве способа обобщения классов,
        когда поведение не может быть спрогнозировано до написания кода более специфического подкласса. Объектно-
        ориентированные фреймворки также применяют их как способ направления на определяемые клиентом настраиваемые
        операции.

    2. Что происходит, когда простое присваивание появляется на верхнем уровне
    оператора class?
    
    Ответ: 
        Когда простой оператор присваивания (X = Y) появляется на верхнем уровне
    оператора class, он присоединяет к классу атрибут данных (Класс.Х). Подобно всем атрибутам класса он будет 
    разделяться всеми экземплярами; тем не менее, атрибуты данных не являются вызываемыми функциями методов.
    
    3. Почему в классе может возникнуть потребность в ручном вызове метода
        __ init__ суперкласса?
    
    Ответ:
        В классе должен вызываться метод __init__ суперкласса, если в нем определяется собственный 
        конструктор __init__ и нужно, чтобы код конструктора суперкласса по-прежнему выполнялся. 
        Сам интерпретатор Python автоматически запускает только один конструктор - самый нижний в дереве.
        Конструктор суперкласса обычно вызывается через имя класса с передачей экземпляра self вручную:
        Суперкласс.__init__(self, ...).
    
    4. Как можно дополнить унаследованный метод, не замещая его полностью?
    
    Ответ:
        Чтобы вместо замещения дополнить унаследованный метод, его понадобиться повторно определить
        в подклассе, но внутри этой новой версии вызвать версию метода из суперкласса с передачей ей
        экземпляра self: Суперкласс.метод(self, ...)
    5. Чем локальная область видимости класса отличается от локальной области ви­димости функции?
    
    Ответ:
        Класс представляет собой локальную область видимости и имеет доступ к объемлющим локальным 
        областям видимости, но он не служит в качестве локальной области видимости для добавочного 
        вложенного кода. Подобно модулям после выполнения оператора class локальная область видимости 
        класса превращается в пространство имен атрибутов.